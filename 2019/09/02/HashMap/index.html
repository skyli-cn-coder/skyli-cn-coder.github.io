<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>HashMap 浅析 | SkyLi's Blog</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashMap 浅析</h1><a id="logo" href="/.">SkyLi's Blog</a><p class="description">向往天空-展翅翱翔</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">HashMap 浅析</h1><div class="post-meta"><a href="/2019/09/02/HashMap/#comments" class="comment-count"></a><p><span class="date">Sep 02, 2019</span><span><a href="/categories/JSE/" class="category">JSE</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="HashMap概述："><a href="#HashMap概述：" class="headerlink" title="HashMap概述："></a><strong>HashMap概述</strong>：</h3><p>HashMap实现了映射关系接口Map,是一种可处理键值对的数据结构。在日常开发中，HashMap 经常用来临时存放数据。其底层数据结构基本能达到 O(1) 的查询性能。</p>
<h3 id="HashMap数据结构："><a href="#HashMap数据结构：" class="headerlink" title="HashMap数据结构："></a><strong>HashMap数据结构</strong>：</h3><p>在 JDK7 中 HashMap 底层数据结构采用的是： 数组 + 链表。 该中数据结构的组合基本能满足 HashMap 的功能。但是随着数据量激增的情况下，频繁的 Hash 冲突使链表的长度逐渐增长，有可能查询性能退化成 O(n)。<br>JDK8 中引入了红黑树，利用红黑树的强大性能来解决 HashMap 的性能问题。 下面是 HashMap 底层数据结构的声明定义：</p>
<blockquote>
<p>数组：<figure class="highlight plain"><figcaption><span>table ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 链表： </span><br><span class="line">``` java</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>红黑树（JDK8）：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       TreeNode&lt;K,V&gt; left;</span><br><span class="line">       TreeNode&lt;K,V&gt; right;</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">       <span class="keyword">boolean</span> red;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap功能实现："><a href="#HashMap功能实现：" class="headerlink" title="HashMap功能实现："></a><strong>HashMap功能实现</strong>：</h3><p>熟悉 HashMap 的功能实现之前，先来看下 HashMap 中几个基本概念：</p>
<p> <strong>基本概念</strong>：</p>
<pre><code>1、length:table的长度

2、loadFactor: map 负载因子 

3、threshold: threshold = length * loadFactor： 当HashMap中的key的数量达到该值时会自动扩容。
</code></pre><p><strong>有参构造方法:</strong></p>
<p>HashMap 默认无参构造方法会初始化一个默认大小为 16 的实例。这里主要看下有参有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  loadFactor);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 初始化负载因子</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); <span class="comment">// threshold 存放初始hash桶数组大小，后边在首次put对象过程中初始化hashTable时会用到</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>tableSizeFor 解析（NB）：</strong></p>
<p>在构造hashMap时，构造方法会根据实参（cap）来计算hash桶数组长度。计算方法为：tableSizeFor<br>该函数作用：根据传进来的参数得到大于且最接近该参数并且是2的幂次方的数字作为hash桶数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数第一行 <figure class="highlight plain"><figcaption><span>n </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弄清原因之前我们需要先来看下该函数主要做了什么操作：该函数主要对cap 进行了一系列的移位或操作，这些操作的目的是什么？我们取一个数字并将以为过程展示出来:</span><br><span class="line">这里我们假设</span><br><span class="line">```math</span><br><span class="line">n = 2^&#123;31&#125;</span><br></pre></td></tr></table></figure></p>
<p>则每次的移位或操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       n=  ***     ;  <span class="number">1000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;  <span class="number">1100</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将最高位拷贝到下<span class="number">1</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;  <span class="number">1111</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">2</span>位拷贝到紧接着的<span class="number">2</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">4</span>位拷贝到紧接着的<span class="number">4</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">8</span>位拷贝到紧接着的<span class="number">8</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  将上述<span class="number">16</span>位拷贝到紧接着的<span class="number">16</span>位</span><br></pre></td></tr></table></figure></p>
<p>上述操作的最终目的是要把 n 的最高位右边的所有位置 1 。一遍可以找出大于该数并且是2的幂次方。那为什么要在移位或操作前先进行 cap -1 操作呢？因为如果 cap 已经是2的幂次方了（说明cap 已经满足要求，那该函数最终应该返回cap），如果不进行 cap -1 操作的话，该函数最终将返回 cap * 2，这显然不符合要求。</p>
<p><strong>定位Node所在哈希桶索引:</strong></p>
<p>hash(key) -&gt; 高位运算 -&gt; 取模运算</p>
<p>1、key hashcode + 高位运<em>**</em>算：<br>hashMap 中针对key 有专门的hash函数，该函数在Object hash值的基础上取其高16位进行了异或操作。这样做的目的是在hash桶length长度比较小的时候，让Object hash 的高位也能参与到取模操作中，能在一定程度上减少hash冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>2、取模运算: hash &amp; (table.length - 1)<br>在计算 Node 在 hash 桶数组的位置时，通常需要将 hash 值与桶数组长度取模操作：<figure class="highlight plain"><figcaption><span>% table.length```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">上文中在构造hashMap时 ```tableSizeFor```函数的返回值即 hash 桶数组的长度。该返回值是一个 2 的幂次方的数字。</span><br><span class="line">而 ```hash &amp; (table.length - 1)``` 与 ```hash % table.length``` 在```table.length```是 2 的幂次方时的作用是一样的，</span><br><span class="line">且 &amp; 操作 比 % 操作  占用的 cpu 周期更少，所以其效率更高。</span><br><span class="line">下面是 HashMap get(Object key) 底层获取 Node 的源码， 在代码中我们可以看到使用位运算确定 Node 下标的代码：</span><br><span class="line">``` java</span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;// 根据 key 的 hash 值确定 key 在 Hash 桶数组中的下标</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>向HashMap中加入键值对：</strong></p>
<p>下面看下 HashMap 在插入键值对时做了什么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果该Map第一次put对象，则初始化hash桶数组。</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 如果指定索引位置没有元素，则创建节点并放入改索引对应的数组中</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定索引位置有元素</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 如果存在的节点与将要插入的节点相同，则直接替换</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//如果不相同，则判断存在节点是否是树化节点，是，则将插入节点插入红黑树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 不是树化节点，则遍历该索引桶中的链表，将节点插入链表末尾</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//插入过程中判断链表是否需要转成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 初始化value或者替换老的value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从 put() 源码中我们可以看到，HashMap在首次put时才初始化hash桶数组，这种设计理念很好的避免了初始加载的内存浪费问题（要避免占着坑位不拉**的场景）。</p>
<p><strong>HashMap 扩容：</strong></p>
<p>HashMap 在元素数量达到 threshold 时会进行扩容操作。JDK8 较 JDK7 在扩容操作上作了一定优化，但是基本过程相差不大，下面先看下 JDK7 中的扩容代码：<br>1、JDK7:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123; <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">          threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7 当HashMap 扩容时直接创建一个新的hash桶数组其大小为原数组长度2倍，并将原数组Node重新hash迁移到新数组中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！！重新计算每个元素在数组中的位置（重新取模操作计算新数组下标）</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//记录原索引指向的节点</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 这里迁移后的数据中，同一个索引的链表会出现倒置问题，详情看下图</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面以图例简单描述下迁移过程：</p>
<p>扩容前：</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190807225633.png" alt="扩容前"></p>
<p>扩容后：</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190807230010.png" alt="扩容后"></p>
<p>这里注意下元素迁移过程中的规律，假设 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">扩容前下标：</span><br><span class="line"></span><br><span class="line">| 字段名称 |  value(二进制) |数组下标|</span><br><span class="line">| --- | --- |---|</span><br><span class="line">| length - 1 | 0000 0000 0000 0000 0000 0000 0000 0011 | |</span><br><span class="line">| hash(key1) | 0010 0000 0110 0000 0000 0000 0000 0010 | 2|</span><br><span class="line">| hash(key2) |0010 0000 0110 0000 0000 0000 0000 0110 | 2|</span><br><span class="line">| hash(key3) |0010 0000 0110 0000 0000 0000 0000 0110 | 2 |</span><br><span class="line"></span><br><span class="line">扩容后下标：</span><br><span class="line"></span><br><span class="line">| 字段名称 |  value(二进制) |数组下标|</span><br><span class="line">| --- | --- |---|</span><br><span class="line">| length - 1 | 0000 0000 0000 0000 0000 0000 0000 0111 | |</span><br><span class="line">| hash(key1) | 0010 0000 0110 0000 0000 0000 0000 0010 | 2|</span><br><span class="line">| hash(key2) |0010 0000 0110 0000 1000 0000 0000 0110 | 6 (2 + 4）|</span><br><span class="line">| hash(key3) |0010 0000 0110 0000 0000 0000 0000 0110 | 6  (2 + 4) |</span><br><span class="line"></span><br><span class="line">当数组扩容后，则``` length -1 ``` 二进制在高位会多一个 1， 即：上表（```length -1 ``` 最低4位）中的 ```0011 -&gt; 0111```, </span><br><span class="line">所以凡是``` hash(key)``` 的二进制位（上表中参与运算的最低 4 位）与扩容前的 ```length``` 的二进制非零最高位（即0100 ）相与不为 0 的，则在扩容后的数组中下标为 ```oldIndex + oldCap```.</span><br><span class="line"></span><br><span class="line">JDK8 的这种设计非常巧妙，不仅在针对将老 Hash 桶数组中的数据迁移到新数组中不用重新计算每个 Node 的 hash 值与新数组的取模操作；而且由于每个 key 的 hash 值中对应新增的 1bit 是 0 还是 1 是随机的，这就保证了在扩容前由于 hash 冲突而组成链表节点可以均匀的分散到新的 bucket 中。 并且迁移后的数据不存在倒置问题。</span><br><span class="line">详情看 JDK8 的 resize（）：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;// 如果数组容量已经达到最大值，则调整阈值后直接返回不进行扩容。</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则直接将通数组length * 2</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;// 这里第一次初始化通数组时容量取tableSizeFor函数的返回值。该值被复制在 threshold 变量中。</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];// 创建新的length的数组</span><br><span class="line">        table = newTab;</span><br><span class="line">        // 数据迁移</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;// 遍历原数组的所有链表</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;// 释放原节点空间</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;// 如果链表只有一个节点，则直接将节点放入对应下标的新hash桶数组中。</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        // 遍历链表</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;// 这一步非常NB， 判断key的hash值在新增的1 bit 是否是 1， 如果是 则将其放入hiHead或者hiTail链表中。</span><br><span class="line">                                if (loTail == null)// 尾插</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null) // 尾插</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead; // 将loHead指向的链表放入低bucket（见元素转移图）</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead; // 直接将hiHead 指向的链表放入高bucket中（见元素转移图）</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>JDK8 中采用 4 个 Node（hiHead、hiTail、loHead、loTail）节点(采用尾插发)来保证转移后的高低 bucket 中的链表顺序，不会出现 JDK7 中链表转移到新数组中的倒置问题。</p>
<p><strong>HashMap使用注意事项：</strong></p>
<pre><code>1、禁止使用可变对象作为key.
</code></pre><p>任何对象的 hashcode 方法继承于 Object 基类。其取对象在堆内存中的对象的起始地址，如果选择重写对象的 hashcode 方法，则 hashcode 的生成应尽量避免关联对象属性。否则，在改变对象的 field 属性时，对应的 hashcode 值也会变更，从而无法操作先前存入的 value，造成内存泄漏。</p>
<pre><code>2、非线程安全，多线程并发可能会产生数据不一致问题。
</code></pre><p>可使用 Hashtable 或者 ConcurrentHashMap 替换。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q1 mackong</strong></p>
<blockquote>
<p>tableSizeFor 方法中，求 hashTable 的长度时，为什么取 <code>capacity -1</code> ?</p>
</blockquote>
<p><strong>A1</strong><br>说为什么要用 <code>capacity -1</code> 之前，需要先说明一下</p>
<p>n |= n &gt;&gt;&gt; 1;</p>
<p>n |= n &gt;&gt;&gt; 2;</p>
<p>n |= n &gt;&gt;&gt; 4;</p>
<p>n |= n &gt;&gt;&gt; 8;</p>
<p>n |= n &gt;&gt;&gt; 16;</p>
<p>(移位并或运算)的作用是什么：这5次操作可将任何一个int类型的数字最高位右边的所有二进制位置 1。<br>hashMap 要求桶数组长度必须为 2 的幂次方。所以假设 capacity 已经是2的幂次方，如果不进行<code>capacity-1</code>操作的话，经过上述移位并或运算后，最终函数返回的是<code>capacity * 2</code>的大小</p>
<p><strong>Q2 mackong</strong></p>
<blockquote>
<p>为什么取模操作使用 <code>&amp;（table.length - 1）</code> 而不是 <code>%table.length</code> ?</p>
</blockquote>
<p><strong>A2</strong><br>由上文的<code>tableSizeFor</code> 方法可知， hashMap 的 bucket 桶数组长度是 2 的幂次方。<br>所以 <code>hash(key) &amp; (table.length - 1)</code> 功能上等价于 <code>hash(key)%table.length</code>,<br> 但是 &amp; 操作 比 % 操作在底层计算时占用的 cpu 周期数不同， 在性能上 &amp; 运算要优于直接 %。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: SkyLi</p><p>原文链接: <a href="http://yoursite.com/2019/09/02/HashMap/">http://yoursite.com/2019/09/02/HashMap/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/JCF/">JCF</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/13/COWArrayList/" class="pre">CopyOnWriteArrayList 浅析</a><a href="/2019/01/31/how-to-use-elastic-job/" class="next">Elastic-Job 使用详解</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap概述："><span class="toc-text">HashMap概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap数据结构："><span class="toc-text">HashMap数据结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap功能实现："><span class="toc-text">HashMap功能实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-amp-A"><span class="toc-text">Q&amp;A</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/COWArrayList/">CopyOnWriteArrayList 浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/HashMap/">HashMap 浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/how-to-use-elastic-job/">Elastic-Job 使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/06/dsaa_01/">算法复杂度分析(上)：时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/what-is-the-encoding/">彻底搞懂计算机编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/hystrix-principle/">菜鸟浅谈Hystrix</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JSE/">JSE</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件-Elastic-job/">中间件:Elastic-job</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技巧/">技巧</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JUC/" style="font-size: 15px;">JUC</a> <a href="/tags/JCF/" style="font-size: 15px;">JCF</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/日常/" style="font-size: 15px;">日常</a> <a href="/tags/弹性计算/" style="font-size: 15px;">弹性计算</a> <a href="/tags/高可用/" style="font-size: 15px;">高可用</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.wangfeng.pro" title="WANGFENG" target="_blank">WANGFENG</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">SkyLi.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>