---
title: 算法复杂度分析(上)：时间复杂度
date: 2019-01-06 22:12:45
categories: 计算机基础
tags: [数据结构与算法]
---

正式进入专题之前，首先给一张关于数据结构与算法的图谱：图片来源与极客时间王争大神的数据结构与算法专栏课中。

![数据结构与算法](https://raw.githubusercontent.com/lz330718637/Images/master/20190131150357.png)
下面我们进入正题：
数据结构与算法的目的就是让我们的程序执行时间更快，存储空间更省。那我们如何来评价一个算法的好坏，评价的依据又是什么呢？

1. 为什么需要复杂度分析？

你可能会疑惑？复杂度分析的意义是什么？一段代码执行时间的快慢随时可以在机子上测试出来，而且测试出来的准确度肯定是比我们通过推理分析得出的复杂度分析更加准确！

没错，一段代码的执行效率我们确实可以实际的测出来，但是通过这种手段测出的代码执行效率是不具有普遍代表性的，因为一段代码执行效率的好坏是与执行代码的环境紧密相关的，一段相同的代码分别在几年前的老电脑和现在的电脑上运行，执行的时间肯定是不同的！而且这种“事后统计”的方法针对我们写出好的程序的预判性是没有太大的帮助的。


所以，算法的复杂度分析还是存在很大价值的！它可以大致的评估出我们程序的性能！算法的执行效率通俗的说就是就是算法的执行时间。比如下面的一段代码：

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }

```
这段代码在计算机CPU中执行无外乎就是每行代码的读取、计算，写数据等操作，尽管每行代码在CPU中执行的时间不一样，但是我么这里只做粗略的计算，假设每行代码在CPU中的执行时间是相同的，这里记为：unit_time，则上述所有代码行的执行时间就是2*unit_time + 2n*unit_time。我们将执行总时间记为：T(n) = 2*unit_time + 2n* unit_time。可以看出代码执行的总是间与n成正比。

所以执行总时间总结为一个公式就为：T(n)=O(f(n)), 其中T（n）就是代码运行的总时间，O表示执行时间与n成正比。这就是大O时间复杂度表示法。

通常，大O表示的不是某段代码的具体执行时间，而是表示代码执行时间与随代码规模n增长的变化趋势，所以，在时间复杂度表示中，常量、系数等对增长趋势影响并不大，故上述代码的时间复杂度可以表示为O（n）。

2.常见的时间复杂度类别分析实例：

![时间复杂度类别](https://raw.githubusercontent.com/lz330718637/Images/master/20190131150143.png)
* 常量阶O(1)
常量阶O(1)并不表示代码只执行了一行，通常代码中只要没有循环，递归；则再多的代码时间复杂度也为O(1).
栗如：
```
 int i = 8;
 int j = 6;
 int sum = i + j;
```

* 对数阶O(logn)
栗如：
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }

```
上述代码的时间复杂度为：O(logn)。不论以几为底的对数都表示为O(logn)，因为都可以互相转化为对应常数系数：C*logn，而O(logn)=O(C*lobn)。

还有其他一些类别的复杂度，这里就不举例子了，上述的复杂度类别涵盖了现实中90%的算法复杂度！


